<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>YUMI</title>
  <link rel="stylesheet" href="style.css" />
  <link rel="icon" href="favicon.png" sizes="32x32" type="image/png"/>
  <link rel="icon" href="favicon.png" sizes="16x16" type="image/png"/>
</head>
<body>

  <div class="overlay"></div>
  <div class="container"></div>  
  <header>
    <div class="language-switcher">
      <button data-lang="en">EN</button>
      <button data-lang="it">IT</button>
      <button data-lang="es">ES</button>
      <button data-lang="eo">EO</button>
    </div>
    <div class="audio-control" onclick="toggleMusic()">🎧</div>

    <div class="logo-title">
      <img src="favicon.png" alt="Logo -Pino-" class="logo">
      <h1>YUMI</h1>
    </div>
  </header>
 
  <main>
    <section id="description"></section>

    <div class="links">
      <a href="https://www.https://pino-npg.github.io/Pino/" target="_blank">Pino</a>
    </div>

    <div class="links">
      <a href="https://opensea.io/collection/yumi-664115313" target="_blank">Opensea</a>
      <a href="https://rarible.com/collection/base/0x95f58e17fda667283cb44a09ba45951fa0d3a38e/items" target="_blank">Rarible</a>
      <h2></h2>
      <ul>
    </section>
  </main>

  <audio id="bg-music" loop></audio>

  <script>
    const descriptions = {
      en: `YUMI is a generative NFT collection of 1,000 anime girls, distributed on the Base network.
Each character is unique and generated using custom scripts based on the HashLips engine.
Technical features:
- Total collection: 1,000 NFTs
- Standard: ERC-721
- Network: Base Metadata on IPFS
- Static JSON generated by custom scripts
- Rarity: NFTs feature rarity details that enhance the collection.
- Integrated royalties: percentages defined in the metadata
File structure
The collection is composed of:
- images → generated PNG images
- json → NFT metadata with attributes, name, description, royalties, rarity
- banner → image for branding the collection
- README → this page
Smart Contract
- Contract name: YUMI
- Address: 0x95f58e17fdA667283Cb44a09Ba45951fa0D3a38E
- Compiled with: Solidity 0.8.20 (with optimization)
- Framework: OpenZeppelin Contracts
Modules and tools used
- HashLips Art Engine
- Filebase
- Lighthouse
- Custom .mjs and .js scripts for:
- sorting by rarity
- batch mint NFTs on Base
- Visual Studio Code
Project by -Pino-`,
      it: `YUMI è una collezione NFT generativa composta da 1.000 ragazzine anime, distribuite sulla rete Base. 
      Ogni personaggio è unico e generato tramite script personalizzati basati sull’engine HashLips.
Caratteristiche tecniche:
- Collezione totale: 1000 NFT
- Standard: ERC-721
- Rete: Base Metadati su IPFS 
- JSON statici generati da script personalizzati
- Rarità: negli NFT sono presenti particolari di rarità che impreziosiscono la collezione. 
- Royalties integrate: percentuali definite nei metadata
Struttura dei file
La collezione è composta da:
- images → immagini PNG generate
- json → metadata NFT con attributi, nome, descrizione, royalties, rarità
- banner → immagine per il branding della collezione
- README → questa pagina
Smart Contract
- Nome contratto:YUMI
- Indirizzo:0x95f58e17fdA667283Cb44a09Ba45951fa0D3a38E 
- Compilato con: Solidity 0.8.20 (con ottimizzazione)
- Framework: OpenZeppelin Contracts
Moduli e strumenti utilizzati
- HashLips Art Engine
- Filebase
- Lighthouse
- Script custom .mjs e js per:
  - ordinamento per rarità
  - batch mint NFT su Base
- Visual Studio Code
Progetto firmato -Pino-`,
      es: `YUMI es una colección generativa de NFT de 1000 chicas de anime, distribuida en la red Base.
Cada personaje es único y se genera mediante scripts personalizados basados en el motor HashLips.
Características técnicas:
- Colección total: 1000 NFT
- Estándar: ERC-721
- Red: Metadatos Base en IPFS
- JSON estático generado mediante scripts personalizados
- Rareza: Los NFT presentan detalles de rareza que enriquecen la colección. Regalías integradas: porcentajes definidos en los metadatos
Estructura del archivo
La colección se compone de:
- Imágenes → Imágenes PNG generadas
- JSON → Metadatos de NFT con atributos, nombre, descripción, regalías y rareza
- Banner → Imagen para la marca de la colección
- LÉAME → Esta página
Contrato inteligente
- Nombre del contrato: YUMI
- Dirección: 0x95f58e17fdA667283Cb44a09Ba45951fa0D3a38E
- Compilado con: Solidity 0.8.20 (con optimización)
- Framework: OpenZeppelin Contracts
Módulos y herramientas utilizadas
- HashLips Art Engine
- Filebase
- Lighthouse
- Scripts .mjs y .js personalizados para:
- Ordenar por rareza
- Generar NFT por lotes en Base
- Visual Studio Code
Proyecto de -Pino-`,
      eo: `YUMI estas generativa NFT-kolekto de 1000 anime-knabinoj, distribuitaj en la reto Base.
Ĉiu rolulo estas unika kaj generita per kutimaj skriptoj bazitaj sur la HashLips-motoro.
Teknikaj trajtoj:
- Tuta kolekto: 1000 NFT-oj
- Normo: ERC-721
- Reto: Bazaj Metadatumoj sur IPFS
- Statika JSON generita per kutimaj skriptoj
- Maloftaĵo: NFT-oj havas detalojn pri maloftaĵo, kiuj plibonigas la kolekton. - Integritaj tantiemoj: procentoj difinitaj en la metadatenoj
Dosierstrukturo
La kolekto konsistas el:
- bildoj → generitaj PNG-bildoj
- json → NFT-metadatenoj kun atributoj, nomo, priskribo, tantiemoj, maloftaĵo
- standardo → bildo por marki la kolekton
- README → ĉi tiu paĝo
Inteligenta Kontrakto
- Kontrakta nomo: YUMI
- Adreso: 0x95f58e17fdA667283Cb44a09Ba45951fa0D3a38E
- Kompilita per: Solidity 0.8.20 (kun optimumigo)
- Kadro: OpenZeppelin Contracts
Moduloj kaj iloj uzitaj
- HashLips Art Engine
- Dosierbazo
- Lumturo
- Propraj .mjs kaj .js-skriptoj por:
- ordigo laŭ maloftaĵo
- aro-kreado de NFT-oj sur Bazo
- Visual Studio-Kodo
Projekto de -Pino-`
    };

    const musicPaths = {
      en: "assets/music/YUMI.mp3",
      it: "assets/music/YUMI.mp3",
      es: "assets/music/YUMI.mp3",
      eo: "assets/music/YUMI.mp3"
    };

    const descEl = document.getElementById("description");
    const audio = document.getElementById("bg-music");

    function setLanguage(lang) {
      descEl.textContent = descriptions[lang];
      audio.src = musicPaths[lang];
      audio.play().catch(() => {});
    }

    function toggleMusic() {
      if (audio.paused) {
        audio.play();
      } else {
        audio.pause();
      }
    }

    document.querySelectorAll(".language-switcher button").forEach((btn) => {
      btn.addEventListener("click", () => {
        setLanguage(btn.dataset.lang);
      });
    });

    // Set default based on browser
    const userLang = navigator.language.slice(0, 2);
    setLanguage(Object.keys(descriptions).includes(userLang) ? userLang : 'en');

    window.addEventListener('click', () => {
      audio.play().catch(() => {});
    }, { once: true });
  </script>
</body>
</html>
